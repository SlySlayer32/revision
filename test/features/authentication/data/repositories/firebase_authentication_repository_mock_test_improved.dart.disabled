// Firebase Authentication Repository Unit Tests
// VGV-compliant unit tests with mocked Firebase services
// Tests repository logic without requiring emulators
// Improved version with VGV best practices

import 'dart:async';

import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:revision/core/error/failures.dart';
import 'package:revision/features/authentication/data/datasources/firebase_auth_data_source.dart';
import 'package:revision/features/authentication/data/repositories/firebase_authentication_repository.dart';
import 'package:revision/features/authentication/domain/entities/user.dart';
import 'package:revision/features/authentication/domain/exceptions/auth_exception.dart';

// VGV Test Data Factory - Reduces duplication and improves maintainability
class TestDataFactory {
  /// Creates a User with configurable properties for flexible testing
  static User createUser({
    String? id,
    String? email,
    String? displayName,
    String? photoUrl,
    bool isEmailVerified = false,
    String? createdAt,
    Map<String, dynamic>? customClaims,
  }) {
    return User(
      id: id ?? 'test-user-${DateTime.now().millisecondsSinceEpoch}',
      email: email ?? 'test@example.com',
      displayName: displayName,
      photoUrl: photoUrl,
      isEmailVerified: isEmailVerified,
      createdAt: createdAt ?? DateTime.now().toIso8601String(),
      customClaims: customClaims ?? {},
    );
  }

  /// Creates a verified user for sign-in scenarios
  static User createSignInUser({String? email}) => createUser(
        id: 'signin-feature-id',
        email: email ?? TestConstants.signInEmail,
        displayName: 'Feature User',
        isEmailVerified: true,
        createdAt: '2024-01-01T00:00:00Z',
      );

  /// Creates an unverified user for sign-up scenarios
  static User createSignUpUser({String? email}) => createUser(
        id: 'feature-user-id',
        email: email ?? TestConstants.signUpEmail,
        createdAt: '2024-01-01T00:00:00Z',
      );

  /// Creates a stream user for auth state testing
  static User createStreamUser() => createUser(
        id: 'stream-user-id',
        email: 'stream@example.com',
        displayName: 'Stream User',
        isEmailVerified: true,
        createdAt: '2024-01-01T00:00:00Z',
      );
}

// VGV Test Constants - Centralized test data constants
class TestConstants {
  static const signUpEmail = 'feature.test@example.com';
  static const signInEmail = 'signin.feature@example.com';
  static const invalidEmail = 'invalid-email';
  static const password = 'password123';
  static const weakPassword = 'weak';
  static const specialEmail = 'test+special@example.com';
  static const specialPassword = r'Pass@#$%^&*()123!';

  // Timeout constraints for async tests
  static const defaultTimeout = Duration(seconds: 5);
  static const streamTimeout = Duration(seconds: 3);
  static const networkTimeout = Duration(seconds: 10);
}

// VGV Exception Test Case - For systematic exception testing
class ExceptionTestCase {
  const ExceptionTestCase({
    required this.exception,
    required this.email,
    required this.password,
    required this.description,
    required this.expectedMessage,
  });

  final Exception exception;
  final String email;
  final String password;
  final String description;
  final String expectedMessage;
}

// Mock Firebase Data Source
class MockFirebaseAuthDataSource extends Mock
    implements FirebaseAuthDataSource {}

// VGV Test Verifiers - Separated verification logic
class TestVerifiers {
  static void verifyDataSourceCall<T>(
    MockFirebaseAuthDataSource mockDataSource,
    dynamic Function() call, {
    int times = 1,
  }) {
    verify(call).called(times);
  }

  static void verifySignUpCall(
    MockFirebaseAuthDataSource mockDataSource,
    String email,
    String password,
  ) {
    verify(() => mockDataSource.signUp(email: email, password: password))
        .called(1);
  }

  static void verifySignInCall(
    MockFirebaseAuthDataSource mockDataSource,
    String email,
    String password,
  ) {
    verify(() => mockDataSource.signIn(email: email, password: password))
        .called(1);
  }

  static void verifyNeverCalled(dynamic Function() call) {
    verifyNever(call);
  }
}

// VGV Test Assertions - Separated assertion logic with improved granularity
class TestAssertions {
  static void assertSuccessResult(dynamic result, User expectedUser) {
    expect(result.isRight(), isTrue);
    result.fold(
      (Failure failure) => fail('Expected success, got failure: $failure'),
      (User user) {
        expect(user.email, equals(expectedUser.email));
        expect(user.id, equals(expectedUser.id));
        expect(user.isEmailVerified, equals(expectedUser.isEmailVerified));
        expect(user.displayName, equals(expectedUser.displayName));
      },
    );
  }

  static void assertFailureResult(
    dynamic result,
    String expectedMessageContains,
  ) {
    expect(result.isLeft(), isTrue);
    result.fold(
      (Failure failure) {
        expect(failure, isA<AuthenticationFailure>());
        expect(failure.message, contains(expectedMessageContains));
      },
      (_) => fail('Expected AuthenticationFailure'),
    );
  }

  static void assertSuccessVoid(dynamic result) {
    expect(result.isRight(), isTrue);
    result.fold(
      (Failure failure) => fail('Expected success, got failure: $failure'),
      (_) => expect(true, isTrue),
    );
  }

  static void assertNullResult(dynamic result) {
    expect(result.isRight(), isTrue);
    result.fold(
      (Failure failure) => fail('Expected success, got failure: $failure'),
      (User? user) => expect(user, isNull),
    );
  }
}

void main() {
  group('FirebaseAuthenticationRepository - VGV Compliant Tests', () {
    late FirebaseAuthenticationRepository repository;
    late MockFirebaseAuthDataSource mockDataSource;

    setUp(() {
      mockDataSource = MockFirebaseAuthDataSource();
      repository = FirebaseAuthenticationRepository(
        firebaseAuthDataSource: mockDataSource,
      );
    });

    tearDown(() {
      reset(mockDataSource);
    });

    group('signUpWithEmailAndPassword', () {
      test(
        'should_ReturnUser_When_ValidCredentialsProvided',
        () async {
          // Arrange
          final signUpUser = TestDataFactory.createSignUpUser();
          when(
            () => mockDataSource.signUp(
              email: TestConstants.signUpEmail,
              password: TestConstants.password,
            ),
          ).thenAnswer((_) async => signUpUser);

          // Act
          final result = await repository.signUpWithEmailAndPassword(
            email: TestConstants.signUpEmail,
            password: TestConstants.password,
          );

          // Assert
          TestAssertions.assertSuccessResult(result, signUpUser);
          TestVerifiers.verifySignUpCall(
            mockDataSource,
            TestConstants.signUpEmail,
            TestConstants.password,
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      group('exception handling', () {
        final exceptionTestCases = [
          const ExceptionTestCase(
            exception: InvalidEmailException(),
            email: TestConstants.invalidEmail,
            password: TestConstants.password,
            description: 'invalid email',
            expectedMessage: 'Invalid',
          ),
          const ExceptionTestCase(
            exception: WeakPasswordException(),
            email: TestConstants.signUpEmail,
            password: TestConstants.weakPassword,
            description: 'weak password',
            expectedMessage: 'weak',
          ),
          const ExceptionTestCase(
            exception: EmailAlreadyInUseException(),
            email: TestConstants.signUpEmail,
            password: TestConstants.password,
            description: 'duplicate email',
            expectedMessage: 'already in use',
          ),
        ];

        for (final testCase in exceptionTestCases) {
          test(
            'should_ReturnAuthenticationFailure_When_${testCase.description}',
            () async {
              // Arrange
              when(
                () => mockDataSource.signUp(
                  email: testCase.email,
                  password: testCase.password,
                ),
              ).thenThrow(testCase.exception);

              // Act
              final result = await repository.signUpWithEmailAndPassword(
                email: testCase.email,
                password: testCase.password,
              );

              // Assert
              TestAssertions.assertFailureResult(
                result,
                testCase.expectedMessage,
              );
              TestVerifiers.verifySignUpCall(
                mockDataSource,
                testCase.email,
                testCase.password,
              );
            },
            timeout: const Timeout(TestConstants.defaultTimeout),
          );
        }
      });
    });

    group('signInWithEmailAndPassword', () {
      test(
        'should_ReturnUser_When_ValidCredentialsProvided',
        () async {
          // Arrange
          final signInUser = TestDataFactory.createSignInUser();
          when(
            () => mockDataSource.signIn(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          ).thenAnswer((_) async => signInUser);

          // Act
          final result = await repository.signInWithEmailAndPassword(
            email: TestConstants.signInEmail,
            password: TestConstants.password,
          );

          // Assert
          TestAssertions.assertSuccessResult(result, signInUser);
          TestVerifiers.verifySignInCall(
            mockDataSource,
            TestConstants.signInEmail,
            TestConstants.password,
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      group('exception handling', () {
        final signInExceptionTestCases = [
          const ExceptionTestCase(
            exception: InvalidCredentialsException(),
            email: TestConstants.signInEmail,
            password: 'wrong-password',
            description: 'invalid credentials',
            expectedMessage: 'Invalid',
          ),
          const ExceptionTestCase(
            exception: UserNotFoundException(),
            email: 'nonexistent@example.com',
            password: TestConstants.password,
            description: 'user not found',
            expectedMessage: 'not found',
          ),
        ];

        for (final testCase in signInExceptionTestCases) {
          test(
            'should_ReturnAuthenticationFailure_When_${testCase.description}',
            () async {
              // Arrange
              when(
                () => mockDataSource.signIn(
                  email: testCase.email,
                  password: testCase.password,
                ),
              ).thenThrow(testCase.exception);

              // Act
              final result = await repository.signInWithEmailAndPassword(
                email: testCase.email,
                password: testCase.password,
              );

              // Assert
              TestAssertions.assertFailureResult(
                result,
                testCase.expectedMessage,
              );
            },
            timeout: const Timeout(TestConstants.defaultTimeout),
          );
        }
      });

      test(
        'should_ReturnNetworkFailure_When_NetworkTimeoutOccurs',
        () async {
          // Arrange
          when(
            () => mockDataSource.signIn(
              email: any<String>(named: 'email'),
              password: any<String>(named: 'password'),
            ),
          ).thenThrow(
            TimeoutException('Network timeout', TestConstants.networkTimeout),
          );

          // Act
          final result = await repository.signInWithEmailAndPassword(
            email: TestConstants.signInEmail,
            password: TestConstants.password,
          );

          // Assert
          expect(result.isLeft(), isTrue);
          result.fold(
            (Failure failure) => expect(failure, isA<AuthenticationFailure>()),
            (_) => fail('Expected network failure'),
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );
    });

    group('authStateChanges', () {
      test(
        'should_ReturnStreamOfUserChanges_When_AuthStateChanges',
        () async {
          // Arrange
          final streamUser = TestDataFactory.createStreamUser();
          final userStream = Stream<User?>.fromIterable([
            null,
            streamUser,
            null,
          ]);

          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => userStream);

          // Act
          final stream = repository.authStateChanges;
          final states = await stream.take(3).toList();

          // Assert
          expect(states.length, equals(3));
          expect(states[0], isNull);
          expect(states[1]?.email, equals('stream@example.com'));
          expect(states[1]?.displayName, equals('Stream User'));
          expect(states[2], isNull);

          verify(() => mockDataSource.authStateChanges).called(1);
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_HandleStreamReconnection_AfterError',
        () async {
          // Arrange
          final controller = StreamController<User?>();
          final streamUser = TestDataFactory.createStreamUser();
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => controller.stream);

          // Act
          final stream = repository.authStateChanges;

          // Assert
          expectLater(
            stream,
            emitsInOrder([
              streamUser,
              emitsError(isA<NetworkException>()),
              streamUser, // Recovery after error
              emitsDone,
            ]),
          );

          controller.add(streamUser);
          controller.addError(const NetworkException('Connection lost'));
          controller.add(streamUser); // Simulate reconnection
          await controller.close();
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_HandleStreamTransitions_WithProperTiming',
        () async {
          // Arrange
          final controller = StreamController<User?>();
          final streamUser = TestDataFactory.createStreamUser();
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => controller.stream);

          // Act
          final stream = repository.authStateChanges;

          // Assert
          expectLater(
            stream,
            emitsInOrder([
              null,
              streamUser,
              null,
              emitsDone,
            ]),
          );

          controller.add(null);
          controller.add(streamUser);
          controller.add(null);
          await controller.close();
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_ReturnEmptyStream_When_NoAuthStateChanges',
        () async {
          // Arrange
          const emptyStream = Stream<User?>.empty();
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => emptyStream);

          // Act
          final stream = repository.authStateChanges;
          final states = await stream.toList();

          // Assert
          expect(states, isEmpty);
          verify(() => mockDataSource.authStateChanges).called(1);
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_HandleStreamErrors_When_AuthStateStreamFails',
        () async {
          // Arrange
          final errorStream = Stream<User?>.error(
            const NetworkException('Auth state stream error'),
          );
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => errorStream);

          // Act & Assert
          final stream = repository.authStateChanges;
          expect(
            stream.toList(),
            throwsA(isA<NetworkException>()),
          );
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_NotLeakMemory_When_StreamSubscriptionsCancelled',
        () async {
          // Arrange
          final controller = StreamController<User?>.broadcast();
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => controller.stream);

          // Act
          final subscriptions = <StreamSubscription<User?>>[];

          for (var i = 0; i < 10; i++) {
            final subscription = repository.authStateChanges.listen((_) {});
            subscriptions.add(subscription);
          }

          // Cancel all subscriptions
          for (final subscription in subscriptions) {
            await subscription.cancel();
          }

          // Assert - Controller should still be functional
          expect(controller.hasListener, isFalse);
          await controller.close();
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );
    });

    group('signOut', () {
      test(
        'should_ReturnSuccess_When_SignOutSucceeds',
        () async {
          // Arrange
          when(() => mockDataSource.signOut()).thenAnswer((_) async {});

          // Act
          final result = await repository.signOut();

          // Assert
          TestAssertions.assertSuccessVoid(result);
          verify(() => mockDataSource.signOut()).called(1);
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_ReturnAuthenticationFailure_When_SignOutFails',
        () async {
          // Arrange
          when(() => mockDataSource.signOut()).thenThrow(
            const UnexpectedAuthException('Sign out failed'),
          );

          // Act
          final result = await repository.signOut();

          // Assert
          expect(result.isLeft(), isTrue);
          result.fold(
            (Failure failure) => expect(failure, isA<AuthenticationFailure>()),
            (_) => fail('Expected failure for sign out error'),
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );
    });

    group('getCurrentUser', () {
      test(
        'should_ReturnUser_When_UserIsSignedIn',
        () async {
          // Arrange
          final signInUser = TestDataFactory.createSignInUser();
          when(() => mockDataSource.currentUser).thenReturn(signInUser);

          // Act
          final result = await repository.getCurrentUser();

          // Assert
          expect(result.isRight(), isTrue);
          result.fold(
            (Failure failure) =>
                fail('Expected success, got failure: $failure'),
            (User? user) {
              expect(user?.email, equals(TestConstants.signInEmail));
              expect(user?.displayName, equals('Feature User'));
            },
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_ReturnNull_When_NoUserIsSignedIn',
        () async {
          // Arrange
          when(() => mockDataSource.currentUser).thenReturn(null);

          // Act
          final result = await repository.getCurrentUser();

          // Assert
          TestAssertions.assertNullResult(result);
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_ReturnAuthenticationFailure_When_GetCurrentUserFails',
        () async {
          // Arrange
          when(() => mockDataSource.currentUser).thenThrow(
            Exception('Failed to get current user'),
          );

          // Act
          final result = await repository.getCurrentUser();

          // Assert
          expect(result.isLeft(), isTrue);
          result.fold(
            (Failure failure) => expect(failure, isA<AuthenticationFailure>()),
            (_) => fail('Expected failure for getCurrentUser error'),
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );
    });

    group('Edge Cases and Boundary Conditions', () {
      test(
        'should_HandleConcurrentSignInRequests_Gracefully',
        () async {
          // Arrange
          final signInUser = TestDataFactory.createSignInUser();
          when(
            () => mockDataSource.signIn(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          ).thenAnswer((_) async => signInUser);

          // Act
          final futures = List.generate(
            5,
            (_) => repository.signInWithEmailAndPassword(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          );
          final results = await Future.wait(futures);

          // Assert
          for (final result in results) {
            expect(result.isRight(), isTrue);
          }
          verify(
            () => mockDataSource.signIn(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          ).called(5);
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_HandleEmptyCredentials_Gracefully',
        () async {
          // Arrange
          when(
            () => mockDataSource.signIn(
              email: '',
              password: '',
            ),
          ).thenThrow(const InvalidEmailException());

          // Act
          final result = await repository.signInWithEmailAndPassword(
            email: '',
            password: '',
          );

          // Assert
          TestAssertions.assertFailureResult(result, 'Invalid');
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_HandleVeryLongPasswords_Appropriately',
        () async {
          // Arrange
          final longPassword = 'a' * 1000; // 1000 character password
          final signUpUser = TestDataFactory.createSignUpUser();
          when(
            () => mockDataSource.signUp(
              email: TestConstants.signUpEmail,
              password: longPassword,
            ),
          ).thenAnswer((_) async => signUpUser);

          // Act
          final result = await repository.signUpWithEmailAndPassword(
            email: TestConstants.signUpEmail,
            password: longPassword,
          );

          // Assert
          expect(result.isRight(), isTrue);
          TestVerifiers.verifySignUpCall(
            mockDataSource,
            TestConstants.signUpEmail,
            longPassword,
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_HandleSpecialCharactersInCredentials_Correctly',
        () async {
          // Arrange
          final expectedUser = TestDataFactory.createSignInUser(
            email: TestConstants.specialEmail,
          );
          when(
            () => mockDataSource.signIn(
              email: TestConstants.specialEmail,
              password: TestConstants.specialPassword,
            ),
          ).thenAnswer((_) async => expectedUser);

          // Act
          final result = await repository.signInWithEmailAndPassword(
            email: TestConstants.specialEmail,
            password: TestConstants.specialPassword,
          );

          // Assert
          expect(result.isRight(), isTrue);
          result.fold(
            (Failure failure) =>
                fail('Expected success, got failure: $failure'),
            (User user) =>
                expect(user.email, equals(TestConstants.specialEmail)),
          );
          TestVerifiers.verifySignInCall(
            mockDataSource,
            TestConstants.specialEmail,
            TestConstants.specialPassword,
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );
    });

    group('Error Recovery Scenarios', () {
      test(
        'should_RecoverFromTransientNetworkErrors_OnRetry',
        () async {
          // Arrange - First call fails, second succeeds
          final signInUser = TestDataFactory.createSignInUser();
          when(
            () => mockDataSource.signIn(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          )
              .thenThrow(
                TimeoutException(
                  'Network timeout',
                  TestConstants.networkTimeout,
                ),
              )
              .thenAnswer((_) async => signInUser);

          // Act - First attempt fails
          final firstResult = await repository.signInWithEmailAndPassword(
            email: TestConstants.signInEmail,
            password: TestConstants.password,
          );

          // Second attempt succeeds
          final secondResult = await repository.signInWithEmailAndPassword(
            email: TestConstants.signInEmail,
            password: TestConstants.password,
          );

          // Assert
          expect(firstResult.isLeft(), isTrue);
          expect(secondResult.isRight(), isTrue);
          verify(
            () => mockDataSource.signIn(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          ).called(2);
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_HandleIntermittentAuthStateStreamErrors_Gracefully',
        () async {
          // Arrange
          final controller = StreamController<User?>();
          final streamUser = TestDataFactory.createStreamUser();
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => controller.stream);

          // Act
          final stream = repository.authStateChanges;
          final streamResults = <dynamic>[];
          StreamSubscription<User?>? subscription;

          subscription = stream.listen(
            streamResults.add,
            onError: streamResults.add,
          );

          // Emit some values and an error
          controller.add(streamUser);
          controller.addError(const NetworkException('Temporary error'));
          controller.add(null);

          // Wait for stream processing
          await Future<void>.delayed(const Duration(milliseconds: 100));

          // Assert
          expect(streamResults.length, equals(3));
          expect(streamResults[0], equals(streamUser));
          expect(streamResults[1], isA<NetworkException>());
          expect(streamResults[2], isNull);

          // Cleanup
          await subscription.cancel();
          await controller.close();
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_HandleSignOutAfterNetworkError_Successfully',
        () async {
          // Arrange - Sign out fails first, then succeeds
          when(() => mockDataSource.signOut())
              .thenThrow(
                TimeoutException(
                  'Network timeout',
                  const Duration(seconds: 10),
                ),
              )
              .thenAnswer((_) async {});

          // Act - First attempt fails
          final firstResult = await repository.signOut();

          // Second attempt succeeds
          final secondResult = await repository.signOut();

          // Assert
          expect(firstResult.isLeft(), isTrue);
          expect(secondResult.isRight(), isTrue);
          verify(() => mockDataSource.signOut()).called(2);
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );

      test(
        'should_HandleCurrentUserCheckAfterAuthFailure_Correctly',
        () async {
          // Arrange - getCurrentUser fails first, then returns null
          when(() => mockDataSource.currentUser)
              .thenThrow(Exception('Auth state corrupted'))
              .thenReturn(null);

          // Act - First attempt fails
          final firstResult = await repository.getCurrentUser();

          // Second attempt succeeds with null
          final secondResult = await repository.getCurrentUser();

          // Assert
          expect(firstResult.isLeft(), isTrue);
          expect(secondResult.isRight(), isTrue);
          secondResult.fold(
            (Failure failure) =>
                fail('Expected success, got failure: $failure'),
            (User? user) => expect(user, isNull),
          );
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );
    });

    group('Performance and Resource Management', () {
      test(
        'should_HandleMultipleStreamSubscriptions_Efficiently',
        () async {
          // Arrange
          final controller = StreamController<User?>.broadcast();
          final streamUser = TestDataFactory.createStreamUser();
          when(() => mockDataSource.authStateChanges)
              .thenAnswer((_) => controller.stream);

          // Act - Create multiple subscriptions
          final subscriptions = <StreamSubscription<User?>>[];
          final results = <List<User?>>[];

          for (var i = 0; i < 5; i++) {
            final userList = <User?>[];
            results.add(userList);
            final subscription = repository.authStateChanges.listen(
              userList.add,
            );
            subscriptions.add(subscription);
          }

          // Emit test data
          controller.add(streamUser);
          controller.add(null);

          // Wait for processing
          await Future<void>.delayed(const Duration(milliseconds: 50));

          // Assert - All subscriptions should receive the same data
          for (final userList in results) {
            expect(userList.length, equals(2));
            expect(userList[0], equals(streamUser));
            expect(userList[1], isNull);
          }

          // Cleanup
          for (final subscription in subscriptions) {
            await subscription.cancel();
          }
          await controller.close();

          // Verify data source was called only once
          verify(() => mockDataSource.authStateChanges).called(1);
        },
        timeout: const Timeout(TestConstants.streamTimeout),
      );

      test(
        'should_HandleRapidSuccessiveAuthOperations_WithoutRaceConditions',
        () async {
          // Arrange
          final signInUser = TestDataFactory.createSignInUser();
          when(
            () => mockDataSource.signIn(
              email: TestConstants.signInEmail,
              password: TestConstants.password,
            ),
          ).thenAnswer((_) async {
            // Simulate network delay
            await Future<void>.delayed(const Duration(milliseconds: 10));
            return signInUser;
          });

          when(() => mockDataSource.signOut()).thenAnswer((_) async {
            await Future<void>.delayed(const Duration(milliseconds: 5));
          });

          // Act - Rapid sign in and sign out operations
          final futures = <Future<dynamic>>[];

          for (var i = 0; i < 3; i++) {
            futures.add(
              repository.signInWithEmailAndPassword(
                email: TestConstants.signInEmail,
                password: TestConstants.password,
              ),
            );
            futures.add(repository.signOut());
          }

          final results = await Future.wait(futures);

          // Assert - All operations should complete successfully
          for (var i = 0; i < results.length; i++) {
            expect(
              results[i].isRight(),
              isTrue,
              reason: 'Operation $i should succeed',
            );
          }
        },
        timeout: const Timeout(TestConstants.defaultTimeout),
      );
    });

    group('Data Validation and Sanitization', () {
      final validationTestCases = [
        ('null email', null, TestConstants.password),
        ('null password', TestConstants.signInEmail, null),
        ('whitespace email', '   ', TestConstants.password),
        ('whitespace password', TestConstants.signInEmail, '   '),
      ];

      for (final testCase in validationTestCases) {
        final (description, email, password) = testCase;

        test(
          'should_HandleInvalidInput_When_$description',
          () async {
            // Arrange
            when(
              () => mockDataSource.signIn(
                email: email ?? '',
                password: password ?? '',
              ),
            ).thenThrow(const InvalidEmailException());

            // Act
            final result = await repository.signInWithEmailAndPassword(
              email: email ?? '',
              password: password ?? '',
            );

            // Assert
            expect(result.isLeft(), isTrue);
            result.fold(
              (Failure failure) =>
                  expect(failure, isA<AuthenticationFailure>()),
              (_) => fail('Expected failure for $description'),
            );
          },
          timeout: const Timeout(TestConstants.defaultTimeout),
        );
      }
    });
  });
}
