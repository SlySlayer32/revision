// lib/core/services/vertex_ai_service.dart
import 'dart:typed_data';

import 'package:firebase_vertexai/firebase_vertexai.dart';
import 'package:image/image.dart' as img;

import 'package:revision/core/constants/firebase_constants.dart';
import 'package:revision/core/error/exceptions.dart';

class VertexAIService {
  VertexAIService() {
    final vertexAI = FirebaseVertexAI.instance;

    _geminiModel = vertexAI.generativeModel(
      model: FirebaseConstants.geminiModel,
      generationConfig: GenerationConfig(
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 2048,
      ),
    );

    _imagenModel = vertexAI.generativeModel(
      model: FirebaseConstants.imagenModel,
      generationConfig: GenerationConfig(
        temperature: 0.4,
        maxOutputTokens: 1024,
      ),
    );
  }
  late final GenerativeModel _geminiModel;
  late final GenerativeModel _imagenModel;

  /// Generate editing instructions using Gemini 2.5 Pro
  Future<String> generateEditingPrompt({
    required Uint8List imageBytes,
    required List<Map<String, dynamic>> markers,
    int? retryCount = 0,
  }) async {
    try {
      // Validate image
      await _validateImage(imageBytes);

      // Create content with image and markers
      final content = [
        Content.multi([
          DataPart('image/jpeg', imageBytes),
          TextPart(_buildPromptText(markers)),
        ]),
      ];

      final response = await _geminiModel.generateContent(content);

      if (response.text == null || response.text!.isEmpty) {
        throw const AIProcessingException('Empty response from Gemini model');
      }

      return response.text!;
    } catch (e) {
      if (retryCount! < FirebaseConstants.maxRetryAttempts) {
        await Future.delayed(
          Duration(
              seconds:
                  FirebaseConstants.retryDelay.inSeconds * (retryCount + 1)),
        );
        return generateEditingPrompt(
          imageBytes: imageBytes,
          markers: markers,
          retryCount: retryCount + 1,
        );
      }

      throw AIProcessingException('Failed to generate editing prompt: $e');
    }
  }

  /// Process image with Google Imagen
  Future<Uint8List> processImageWithAI({
    required Uint8List imageBytes,
    required String editingPrompt,
    int? retryCount = 0,
  }) async {
    try {
      // Validate image
      await _validateImage(imageBytes);

      // Create content for image generation
      final content = [
        Content.multi([
          DataPart('image/jpeg', imageBytes),
          TextPart(editingPrompt),
        ]),
      ];

      final response = await _imagenModel.generateContent(content);

      // Extract image data from response
      if (response.candidates.isEmpty) {
        throw const AIProcessingException('No image generated by Imagen model');
      }

      // Handle the response based on actual Imagen response format
      // Note: This will need adjustment based on actual Imagen API response
      final candidate = response.candidates.first;
      if (candidate.content.parts.isEmpty) {
        throw const AIProcessingException('Empty image response from Imagen');
      }

      // Extract image bytes (implementation depends on actual response format)
      return _extractImageFromResponse(candidate);
    } catch (e) {
      if (retryCount! < FirebaseConstants.maxRetryAttempts) {
        await Future.delayed(
          Duration(
              seconds:
                  FirebaseConstants.retryDelay.inSeconds * (retryCount + 1)),
        );
        return processImageWithAI(
          imageBytes: imageBytes,
          editingPrompt: editingPrompt,
          retryCount: retryCount + 1,
        );
      }

      throw AIProcessingException('Failed to process image with AI: $e');
    }
  }

  String _buildPromptText(List<Map<String, dynamic>> markers) {
    return '''
You are a professional photo editor AI. Analyze this image and the marked objects for seamless removal.

Marked objects for removal: ${markers.map((m) => 'Object at normalized position (${m['x']}, ${m['y']})').join(', ')}

Instructions for image editing:
1. Analyze lighting conditions around marked areas
2. Identify background patterns and textures
3. Generate content-aware fill considering:
   - Shadow consistency and natural lighting
   - Texture matching and pattern continuation
   - Color harmonization with surrounding areas
   - Perspective accuracy and depth
4. Ensure no artifacts or obvious editing traces
5. Maintain photo realism and natural appearance
6. Preserve image quality and resolution

Generate precise editing instructions for seamless object removal.
''';
  }

  Future<void> _validateImage(Uint8List imageBytes) async {
    // Check file size
    if (imageBytes.length > FirebaseConstants.maxFileSizeMB * 1024 * 1024) {
      throw ImageProcessingException(
        'Image too large: ${imageBytes.length ~/ (1024 * 1024)}MB. Max: ${FirebaseConstants.maxFileSizeMB}MB',
      );
    }

    // Decode and validate image
    final image = img.decodeImage(imageBytes);
    if (image == null) {
      throw const ImageProcessingException('Invalid image format');
    }

    // Check dimensions
    if (image.width > FirebaseConstants.maxImageSize ||
        image.height > FirebaseConstants.maxImageSize) {
      throw ImageProcessingException(
        'Image too large: ${image.width}x${image.height}. Max: ${FirebaseConstants.maxImageSize}x${FirebaseConstants.maxImageSize}',
      );
    }
  }

  Uint8List _extractImageFromResponse(Candidate candidate) {
    // Implementation depends on actual Imagen response format
    // This is a placeholder that needs to be updated based on real API

    for (final part in candidate.content.parts) {
      if (part is DataPart && part.mimeType.startsWith('image/')) {
        return part.bytes;
      }
    }

    throw const AIProcessingException('No image data found in AI response');
  }
}
